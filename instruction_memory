module instruction_memory(
  	input [31:0] A,        
    output reg [31:0] RD       
);
 	  reg [7:0] memoria [64:0];  // Declaração da memória de instruções

    initial begin
      // addi reg[1] (at), $zero, 10 (add valor 10 ao reg[1]) 001000 00000 00001  00000000 00001010
      memoria[0] = 8'b001000_00;  // addi
      memoria[1] = 8'b000_00001;  // addi
      memoria[2] = 8'b00000000;  // addi
      memoria[3] = 8'b00001010;  // addi
		
      // ADDI reg[2] $v0, $zero, 20 (add valor 20 ao reg[2])
      // 001000 00000 00010 0000000000010100
      memoria[4] = 8'b001000_00;  //addi
      memoria[5] = 8'b000_00010;  //addi
      memoria[6] = 8'b00000000;  //addi
      memoria[7] = 8'b00010100;  //addi
	
      // ADDI reg[3] $v1, $zero, 50 (add valor 50 ao reg[3])
      // 001000 00000 00011 0000000000110010
      memoria[8] = 8'b001000_00;  //addi
      memoria[9] = 8'b000_00011;  //addi
      memoria[10] = 8'b00000000;  //addi
      memoria[11] = 8'b00110010;  //addi
		
      // SW reg[1] $at, 1($zero) (armazena reg[1] em mem[1]+reg[0])
      //101011 00001 00001 0000000000000001
      memoria[12] = 8'b101011_00;  //sw
      memoria[13] = 8'b000_00001;  //sw
      memoria[14] = 8'b00000000;  //sw
      memoria[15] = 8'b00000001;  //sw
	
      // SW reg[2] $v0, 2($zero) (armazena reg[2] em mem[2]+reg[0])
      //101011 00010 00010 0000000000000010
      memoria[16] = 8'b101011_00;  //sw
      memoria[17] = 8'b000_00010;  //sw
      memoria[18] = 8'b00000000;  //sw
      memoria[19] = 8'b00000010;  //sw
	
      // LW reg[1] $at, 1($zero) (carrega mem[1]+reg[0] em reg[1])
      //100011 00001 00001 0000000000000001
      memoria[20] = 8'b100011_00;  //lw
      memoria[21] = 8'b000_00001;  //lw
      memoria[22] = 8'b00000000;  //lw
      memoria[23] = 8'b00000001;  //lw

      // LW $v0, 2($zero) (carrega mem[2]+reg[0] em reg[2])
      //100011 00010 00010 0000000000000010
      memoria[24] = 8'b100011_00;  //lw
      memoria[25] = 8'b000_00010;  //lw
      memoria[26] = 8'b00000000;  //lw
      memoria[27] = 8'b00000010;  //lw

      // add $a1, $v1, $a0 (reg[1] + reg[2] = reg[1])
      //000000 00010 00010 00001 00000 100000
      memoria[28] = 8'b000000_00;  //add
      memoria[29] = 8'b001_00010;  //add
      memoria[30] = 8'b0001_000;  //add
      memoria[31] = 8'b00_100000;  //add
		
      // joga reg[1] em mem[1]
      //101011 00001 00001 0000000000000001
      memoria[32] = 8'b101011_00;  //sw
      memoria[33] = 8'b000_00001;  //sw
      memoria[34] = 8'b00000000;  //sw
      memoria[35] = 8'b00000001;  //sw

      // compara reg[1] e reg[3], se for igual -> fim;
      // 000100 00010 00011 1111111111111111
      memoria[36] = 8'b000100_00;  //beq
      memoria[37] = 8'b001_00011;  //beq
      memoria[38] = 8'b00000000;  //beq
      memoria[39] = 8'b11111111;  //beq to this weird address

      // compara reg[0] e reg[0], se for igual -> instr[28]
      //000100 00000 00000 1111111111111100
      memoria[40] = 8'b000100_00;  //beq
      memoria[41] = 8'b000_00000;  //beq
      memoria[42] = 8'b11111111;  //beq
      memoria[43] = 8'b11111100;  //beq

    end

  always @(A) begin
        // Leitura dos 32 bits da memória baseado no endereço A
        RD[7:0]   = memoria[A+3];
        RD[15:8]  = memoria[A+2];
        RD[23:16] = memoria[A+1];
        RD[31:24] = memoria[A];
  end

endmodule